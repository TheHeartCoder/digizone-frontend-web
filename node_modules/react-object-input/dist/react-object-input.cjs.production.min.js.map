{"version":3,"file":"react-object-input.cjs.production.min.js","sources":["../src/index.tsx"],"sourcesContent":["import React, {useState, ReactElement, useCallback, useRef} from 'react'\n\nexport interface ObjectInputProps<T> {\n  renderItem: (\n    name: string,\n    value: T | undefined,\n    changeName: (newName: string) => void,\n    changeValue: (newValue: T) => void,\n    deleteProperty: () => void\n  ) => ReactElement\n  onChange: (updater: (c: {[name: string]: T}) => {[name: string]: T}) => void\n  obj: {[name: string]: T}\n  renderAdd?: (addItem: () => void) => ReactElement\n  renderEmpty?: () => ReactElement\n}\n\nexport const ObjectInput = <T extends {}>({\n  obj,\n  onChange,\n  renderItem,\n  renderAdd = addItem => <button onClick={addItem}>Add item</button>,\n  renderEmpty\n}: ObjectInputProps<T>) => {\n  const [, setRenderKey] = useState(Math.random())\n  const forceRender = useCallback(() => setRenderKey(Math.random), [])\n\n  // stores the keys and values in order so they can be rendered consistently\n  // updated in parallel with the input, and also checked each render for any\n  // external data changes\n  const localRef = useRef<[string | undefined, T | undefined][]>([])\n\n  // add a new empty item to the local array\n  const addItem = useCallback(() => {\n    localRef.current.push([undefined, undefined])\n    forceRender()\n  }, [forceRender])\n\n  // purge and update items altered externally\n  localRef.current = localRef.current\n    .filter(([key, value]) => !(key && value && !(key in obj)))\n    .map(([key, value]) => [\n      key,\n      key && value && obj[key] !== value ? obj[key] : value\n    ])\n\n  // append any items added externally\n  Object.keys(obj).forEach(key => {\n    if (!localRef.current.find(([k]) => k === key)) {\n      localRef.current.push([key, obj[key]])\n    }\n  })\n\n  return (\n    <>\n      {renderEmpty && !localRef.current.length ? renderEmpty() : null}\n      {localRef.current.map(([name, value], i) => (\n        <React.Fragment key={i}>\n          {renderItem(\n            name || '',\n\n            value,\n\n            newName => {\n              const clash =\n                localRef.current.findIndex(item => item[0] === newName) !== -1\n\n              // prevent overwrites of existing items\n              // TODO work out how to keep this value transiently\n              if (clash && value) {\n                return\n              }\n\n              localRef.current[i] = [newName, value]\n\n              onChange(c => {\n                const updated = {...c}\n\n                if (value) {\n                  updated[newName] = value\n                  if (typeof name === 'string') {\n                    delete updated[name]\n                  }\n                }\n\n                return updated\n              })\n            },\n\n            newValue => {\n              const clash =\n                value === undefined &&\n                localRef.current.findIndex(\n                  item => item[0] === name && item[1] !== undefined\n                ) !== -1\n\n              // prevent overwrites of existing items\n              // TODO work out how to keep this value transiently\n              if (clash) {\n                return\n              }\n\n              localRef.current[i] = [name, newValue]\n\n              if (typeof name === 'string') {\n                onChange(c => ({\n                  ...c,\n                  [name]: newValue\n                }))\n              } else {\n                forceRender()\n              }\n            },\n\n            () => {\n              localRef.current.splice(i, 1)\n              onChange(c => {\n                const updated = {...c}\n                if (typeof name === 'string') {\n                  delete updated[name]\n                }\n                return updated\n              })\n            }\n          )}\n        </React.Fragment>\n      ))}\n\n      {renderAdd(addItem)}\n    </>\n  )\n}\n"],"names":["obj","onChange","renderItem","renderAdd","addItem","React","onClick","renderEmpty","setRenderKey","useState","Math","random","forceRender","useCallback","localRef","useRef","current","push","undefined","filter","key","map","value","Object","keys","forEach","find","length","i","name","Fragment","newName","findIndex","item","c","updated","newValue","splice"],"mappings":"uXAgB2B,gBACzBA,IAAAA,IACAC,IAAAA,SACAC,IAAAA,eACAC,UAAAA,aAAY,SAAAC,UAAWC,0BAAQC,QAASF,kBACxCG,IAAAA,YAESC,EAAgBC,WAASC,KAAKC,aACjCC,EAAcC,eAAY,kBAAML,EAAaE,KAAKC,UAAS,IAK3DG,EAAWC,SAA8C,IAGzDX,EAAUS,eAAY,WAC1BC,EAASE,QAAQC,KAAK,MAACC,OAAWA,IAClCN,MACC,CAACA,WAGJE,EAASE,QAAUF,EAASE,QACzBG,QAAO,gBAAEC,eAAkBA,WAAkBA,KAAOpB,OACpDqB,KAAI,gBAAED,OAAKE,aAAW,CACrBF,EACAA,GAAOE,GAAStB,EAAIoB,KAASE,EAAQtB,EAAIoB,GAAOE,MAIpDC,OAAOC,KAAKxB,GAAKyB,SAAQ,SAAAL,GAClBN,EAASE,QAAQU,MAAK,0BAAeN,MACxCN,EAASE,QAAQC,KAAK,CAACG,EAAKpB,EAAIoB,QAKlCf,gCACGE,IAAgBO,EAASE,QAAQW,OAASpB,IAAgB,KAC1DO,EAASE,QAAQK,KAAI,WAAgBO,OAAdC,OAAMP,cAC5BjB,gBAACA,EAAMyB,UAASV,IAAKQ,GAClB1B,EACC2B,GAAQ,GAERP,GAEA,SAAAS,IAEiE,IAA7DjB,EAASE,QAAQgB,WAAU,SAAAC,UAAQA,EAAK,KAAOF,MAIpCT,IAIbR,EAASE,QAAQY,GAAK,CAACG,EAAST,GAEhCrB,GAAS,SAAAiC,OACDC,OAAcD,UAEhBZ,IACFa,EAAQJ,GAAWT,EACC,iBAATO,UACFM,EAAQN,IAIZM,SAIX,SAAAC,QAEclB,IAAVI,IAGO,IAFPR,EAASE,QAAQgB,WACf,SAAAC,UAAQA,EAAK,KAAOJ,QAAoBX,IAAZe,EAAK,QASrCnB,EAASE,QAAQY,GAAK,CAACC,EAAMO,GAET,iBAATP,EACT5B,GAAS,SAAAiC,uBACJA,cACFL,GAAOO,SAGVxB,QAIJ,WACEE,EAASE,QAAQqB,OAAOT,EAAG,GAC3B3B,GAAS,SAAAiC,OACDC,OAAcD,SACA,iBAATL,UACFM,EAAQN,GAEVM,YAOhBhC,EAAUC"}